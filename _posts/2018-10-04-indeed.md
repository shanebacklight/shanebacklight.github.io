---
layout:     post
title:      Indeed
date:       2019-10-04 09:00:00
author:     "Shane"
excerpt:    ""
header-img: "img/bg-mac.jpg"
catalog: true
tags:
    - OA
---

## String
### KMP
```java
class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.length() ==0){return 0;}
        int[] presuf = helper(needle);
        int m = haystack.length(), n=needle.length(), j=0;
        for(int i=0; i<m; i++){
            while(j>0 && haystack.charAt(i)!=needle.charAt(j)){
                j=presuf[j-1];
            }
            if(haystack.charAt(i)==needle.charAt(j)){
                j++;
            }
            if(j==n){
                return i-n+1;
            }
        }
        return -1;
    }
    
    private int[] helper(String pattern){
        // presuf[i] record the length of longest suffix in pattern ending at pattern[i]
        // suffix mush appears in preffix with same length
        int n = pattern.length();
        int[] presuf = new int[n];
        presuf[0] = 0;
        int j=0;
        for(int i=1; i<n; i++){
            while(j>0 && pattern.charAt(i)!=pattern.charAt(j)){
                // j>0 here is to avoid out of boundary
                j = presuf[j-1];
            }
            if(pattern.charAt(i) == pattern.charAt(j)){
                presuf[i] = j+1;
                j++;
            }
            else{// j=0, next i has to match from head
                presuf[i] = 0;
            }
        }
        return presuf;
    }
}
```
### 340. Longest Substring with At Most K Distinct Characters<br>
Solution 1: Use TreeMap to keep track of the last occurence of each character
```java
class Solution {
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        if(k==0){return 0;}
        int ans = 0, left=0;
        Map<Character, Integer> mp = new HashMap<>();
        TreeMap<Integer, Character> lastOcc = new TreeMap<>();
        for(int i=0; i<s.length(); i++){
            char cur = s.charAt(i);
            if(!mp.containsKey(cur)){
                if(mp.size() == k){
                    int idx = lastOcc.firstKey();
                    left = idx+1;
                    mp.remove(lastOcc.get(idx));
                    lastOcc.remove(idx);
                }

            }
            else{
                lastOcc.remove(mp.get(cur));
            }
            mp.put(cur, i);
            lastOcc.put(i, cur);
            ans = Math.max(ans, i-left+1);
        }
        return ans;
    }
}
```

## Interval
### 759. Employee Free Time<br>
Solution 1: use priority queue
```java
class Solution {
    public List<Interval> employeeFreeTime(List<List<Interval>> schedule) {
        int k = schedule.size();
        Queue<ExtInterval> heap = new PriorityQueue<>(k, (a,b)->a.interval.start-b.interval.start);
        Iterator<Interval>[] iters = (Iterator<Interval>[]) new Iterator[k];
        int i=0;
        for(List<Interval> intervals : schedule){
            iters[i] = intervals.iterator();
            heap.offer(new ExtInterval(iters[i].next(), i));
            i++;
        }
        
        List<Interval> sorted = new ArrayList<>();
        
        while(!heap.isEmpty()){
            ExtInterval top = heap.poll();
            sorted.add(top.interval);
            if(iters[top.group].hasNext()){
                heap.offer(new ExtInterval(iters[top.group].next(), top.group));
            }
        }
        
        List<Interval> free = new ArrayList<>();
        Interval prev = sorted.get(0);
        
        for(int j = 1; j<sorted.size(); j++){
            Interval cur = sorted.get(j);
            if(cur.start > prev.end){
                free.add(new Interval(prev.end, cur.start));
                prev = cur;
            }
            else{
                if(prev.end<cur.end){
                    prev = cur;
                }
            }
        }
        
        return free;
    }
    
    private class ExtInterval{
        Interval interval;
        int group;
        ExtInterval(Interval interval, int group){
            this.interval = interval;
            this.group = group;
        }
    }
}
```
Solution 2: No priority queue, use Collections.sort()
```java
class Solution {
    public List<Interval> employeeFreeTime(List<List<Interval>> schedule) {
        List<Interval> sorted = new ArrayList<>();
        schedule.forEach(each->sorted.addAll(each));
        Collections.sort(sorted, (a, b)->a.start-b.start);
        
        List<Interval> free = new ArrayList<>();
        Interval prev = sorted.get(0);
        
        for(int j = 1; j<sorted.size(); j++){
            Interval cur = sorted.get(j);
            if(cur.start > prev.end){
                free.add(new Interval(prev.end, cur.start));
            }
            prev = cur.end>prev.end? cur : prev; 
        }
        
        return free;
    }
    
    
}
```

## Binary Search
### 410. Split Array Largest Sum
```java
class Solution {
    int[] A;
    int m;
    public int splitArray(int[] nums, int m) {
        
        
        this.m = m;
        A = nums;
        
        int left = Integer.MIN_VALUE;
        int right = 0;
        for(int each : nums){
            left = Math.max(left, each);
            right += each;
        }
        
        while(left<=right){
            int mid = (right-left)/2+left;
            if(validate(mid)){
                right = mid-1;
            }
            else{
                left = mid+1;
            }
        }
        
        return left;
    }
    
    private boolean validate(int volume){
        int count = 1;
        int sum = 0;
        for(int x: A){
            sum += x;
            if(sum>volume){
                sum = x;
                count++;
                if(count>m){
                    return false;
                }
            }
        }
        return true;
    }
    
}
```

## DP
### 410. Split Array Largest Sum<br>
Solution 1: iterative vers.<br>
```java
    public int splitArray(int[] nums, int m) {
        // dp[k][i] = min{ max{dp[k-1][j], A[j+1]+..+A[i]]}, k-2<=j<i}
        // sum[j+1] = A[0]+A[j], sum[0] = 0
        // boundary cond: dp[1][j] = A[0] + A[j] = sum[j+1]-sum[0] = sum[j+1]
        int[] A=nums;
        int[][] dp = new int[m+1][A.length];
        int[] sum = new int[A.length+1];
        sum[0] = 0;
        for(int i=0; i<A.length; i++){
            sum[i+1] = sum[i]+A[i];
            dp[1][i] = sum[i+1];
        }
        
        for(int k=2; k<dp.length; k++){
            for(int i=k-1; i<A.length; i++){
                int ans = Integer.MAX_VALUE;
                for(int j = i-1; j>=k-2;j--){
                    ans = Math.min(ans, Math.max(dp[k-1][j], sum[i+1]-sum[j+1]));
                }
                dp[k][i] = ans;
            }
        }
        return dp[m][A.length-1];
    }
```
Solution 2: recursive vers.<br>
```java
class Solution {
    int[] A;
    int[][] dp;
    boolean[][] visited;
    int[] sum;
    public int splitArray(int[] nums, int m) {
        // dp[k][i] = min{ max{dp[k-1][j], A[j+1]+..+A[i]]}, k-2<=j<i}
        // sum[j+1] = A[0]+A[j], sum[0] = 0
        // boundary cond: dp[1][j] = A[0] + A[j] = sum[j+1]-sum[0] = sum[j+1]
        A=nums;
        dp = new int[m+1][A.length];
        visited = new boolean[m+1][A.length];
        sum = new int[A.length+1];
        sum[0] = 0;
        for(int i=0; i<A.length; i++){
            sum[i+1] = sum[i]+A[i];
            dp[1][i] = sum[i+1];
            visited[1][i] = true;
        }
        
        return helper(m, A.length-1);
    }
    
    private int helper(int k, int i){
        if(visited[k][i]){
            return dp[k][i];
        }
        
        visited[k][i] = true;
        
        int ans = Integer.MAX_VALUE;
        
        for(int j = i-1; j>=k-2; j--){
            ans = Math.min(ans, Math.max(helper(k-1,j), sum[i+1]-sum[j+1]));
        }
        
        dp[k][i] = ans;
        
        return ans;
    }
}
```
Solution 3 : Binary Search, look at Binary section

### 787. Cheapest Flights Within K Stops
```java
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        int[] dp = new int[n];
        int[] tmp = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[src] = 0;
        for(int i=0; i<=K; i++){
            tmp = Arrays.copyOf(dp, n);

            for(int[] flight : flights){
                int u = flight[0];
                int v = flight[1];
                int cost = flight[2];
                if(dp[u] != Integer.MAX_VALUE){
                    tmp[v] = Math.min(tmp[v], dp[u]+cost);
                }
            }
            
            dp = Arrays.copyOf(tmp, n);
        }
        return (dp[dst] == Integer.MAX_VALUE)? -1 : dp[dst];
    }
```
## two pointer
### k way partition<br>
```java
public class Solution {
    public void sortColors2(int[] colors, int k) {
        // write your code here
        int left = 0, right = colors.length-1, i;
        int lowcolor = 1, highcolor = k;
        while(lowcolor<highcolor){
            i=left;
            while(i<=right){
                if(colors[i]==lowcolor){
                    swap(colors, left++, i++);
                }
                else if(colors[i]==highcolor){
                    swap(colors, i, right--);
                }
                else{i++;}
            }
            lowcolor++;
            highcolor--;
        }
    }
    
    private void swap(int[] A, int i, int j){
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }
}
```

## Yama
### 1565. 现代飞行棋
```java
public class Solution {
    /**
     * @param length: the length of board
     * @param connections: the connections of the positions
     * @return: the minimum steps to reach the end
     */
     
    Set<Integer> visited;
    List<Integer>[] g;
    Queue<Integer> q;
    
    public int modernLudo(int length, int[][] connections) {
        // Write your code here
        visited = new HashSet<>();
        g = (List<Integer>[]) new ArrayList[length+1];
        for(int i=1; i<=length; i++){
            g[i] = new ArrayList<>();
        } 
        for(int[] e : connections){
            int from = e[0], to = e[1];
            g[from].add(to);
        }
        q = new ArrayDeque<>();
        q.add(1);
        visited.add(1);
        
        int step = 0;
        while(!q.isEmpty()){
            int size = q.size();
            for(int k = 0; k<size; k++){
                int top = q.poll();
                if(top == length){
                    return step;
                }
                for(int i=1; i<=6; i++){
                    int next = top+i;
                    if(next>length || visited.contains(next)){
                        continue;
                    }
                    helper(next);
                }
            }
            step++;
        }
        return -1;
    }
    
    
    private void helper(int node){
        q.add(node);
        visited.add(node);
        for(int nei : g[node]){
            if(visited.contains(nei)){
                continue;
            }
            else{
                helper(nei);
            }
        }
    }
}
```


