---
layout:     post
title:      Indeed
date:       2019-10-04 09:00:00
author:     "Shane"
excerpt:    ""
header-img: "img/bg-mac.jpg"
catalog: true
tags:
    - OA
---

## Valid Python Indent
```java
public class Solution {
    
    public boolean check(String[] python){
        if(python == null || python.length==0){
            return true;
        }
        int i=0, n = python.length;
        while(i<n && python[i].trim().length()==0){
            i++;
        }
        if(i == n){
            return true;
        }
        if(getIndent(python[i])>0){
            return false;
        }
        Deque<String> stack = new ArrayDeque<>();
        stack.push(python[i++]);
        for(;i<n; i++){
            // remove white space at the right side
            String cur = rtrim(python[i]);
            if(cur.length()==0){
                continue;
            }
            String pre = stack.peek();
            if(pre.charAt(pre.length()-1) == ':'){
                if(getIndent(pre) >= getIndent(cur)){
                    return false;
                }
            }
            else{
                while(getIndent(stack.peek())>getIndent(cur)){
                    stack.pop();
                }
                if(getIndent(stack.peek())!=getIndent(cur)){
                    return false;
                }
            }
            stack.push(cur);
        }
        
        String rest = stack.peek();
        if(rest.charAt(rest.length()-1) == ':'){
            return false;
        }
        
        return true;
    }

    private int getIndent(String python){
        // assume python is not an empty string
        int i = 0, n = python.length();
        while(i<n && python.charAt(i)==' '){
            i++;
        }
        return i;
    }

    private String rtrim(String s){
        int len = s.length();
        while(len>0 && s.charAt(len-1)==' '){
            len--;
        }
        return s.substring(0,len);
    }

}
```
## Unroll List
```java
public class Solution {
    private class Node{
        int cap=5;
        char[] arr = new char[5];
        int len=0;
        Node next;
    }

    Node dummy = new Node();
    int totalLen = 0;

    public char get(int index){
        // index is zero based
        if(index<0 || index>=totalLen){
            throw new IllegalArgumentException("Illegal index");
        }
        Node cur = dummy.next;
        int order = index+1;
        // the if condition would make sure that cur would never be null
        while(order>cur.len){
            order -= cur.len;
            cur = cur.next;
        }
        return cur.arr[order-1];
    }

    public void insert(int index, char item){
        if(index<0 || index>totalLen){
            throw new IllegalArgumentException("illegal index");
        }
        Node pre = dummy;
        int order = index+1;
        while(pre.next!=null && order>pre.next.len){
            order -= pre.next.len;
            pre = pre.next;
        }
        if(pre.next==null){
            pre.next = new Node();
            pre.next.arr[pre.len++] = item;
        }
        else{
            Node cur = pre.next;
            if(cur.len==cur.cap){
                char tmp = cur.arr[cur.len-1];
                cur.arr[pre.len-1] = item;
                Node fresh = new Node();
                fresh.arr[fresh.len++] = tmp;
                fresh.next = cur.next;
                cur.next = fresh;
            }
            else{
                int internalIdx = order-1;
                for(int j = cur.len; j>internalIdx; j--){
                    cur.arr[j] = cur.arr[j-1];
                }
                cur.arr[internalIdx] = item;
            }
        }

        totalLen++;
    }
}
```
## Normalize Title
```java
// reduce to three dp problem.
//version 1: find longest common subsequence of A and B
if(A[i] == B[j]){ dp[i][j] = 1+dp[i+1][j+1];}
else{dp[i][j] = Math.max(dp[i+1][j], dp[i][j+1]);}
return dp[0][0];

//version 2: find longest common substring of A and B
// dp[i][j]: record the longest d, such that A[i,i+d) matches B[j,j+d).
int ans =0;
if(A[i] == B[j]){ dp[i][j] = 1+dp[i+1][j+1];}
else{dp[i][j] = 0;}
ans = Math.max(ans, dp[i][j]);

//version 3: find longest substring of B such that the substring is a subsequence of A
//dp[i][j]ï¼š record the longest d, such that B[j, j+d) is a subsequence of A[i,n)
int ans =0;
if(A[i] == B[j]){ dp[i][j] = 1+dp[i+1][j+1];}
else{dp[i][j] = dp[i+1][j];}
ans = Math.max(ans, dp[i][j]);
```

## GitNode
```java
public class Solution {
    private class Node{
        int lable;
        List<Node> parents;
    }

    public Node findLCA(Node a, Node b){
        if(a==null || b==null){
            return null;
        }
        Set<Node> s1 = new HashSet<>(), s2 = new HashSet<>();
        Queue<Node> q1 = new LinkedList<>(), q2 = new LinkedList<>();

        s1.add(a);
        s2.add(b);
        q1.offer(a);
        q2.offer(b);

        while(!q1.isEmpty() && !q2.isEmpty()){
            int size1 = q1.size();
            for(int i=0; i<size1; i++){
                Node top = q1.poll();
                if(s2.contains(top)){
                    return top;
                }
                for(Node par : top.parents){
                    if(s1.contains(par)){
                        continue;
                    }
                    s1.add(par);
                    q1.offer(par);
                }
            }

            int size2 = q2.size();
            for(int i=0; i<size2; i++){
                Node top = q2.poll();
                if(s1.contains(top)){
                    return top;
                }
                for(Node par : top.parents){
                    if(s2.contains(par)){
                        continue;
                    }
                    s2.add(par);
                    q2.offer(par);
                }
            }
        }
        
        return null;
    }
}
```
## GetAve
```java
public class Solution {
    Deque<long[]> list  = new ArrayDeque<>();
    final long duration = 300000;
    long sum = 0;
    public void record(int val , long timestamp){
        clean();
        sum += val;
        list.addLast(new long[]{val, timestamp});
    }

    public double getAve(){
        clean();
        return sum/list.size();
    }

    public double getMedian(){
        int w = list.size();
        long[] arr = new long[w];
        int i = 0;
        for(long[] item : list){
            arr[i++] = item[1];
        }
        int K = (1+w)/2;
        if((w & (long)1 )== 0){
            return 0.5*(findKth(arr, K) + findKth(arr, K+1));
        }
        else{
            return findKth(arr, K);
        }
    }

    public void clean(){
        long curTime = System.currentTimeMillis();
        while(!list.isEmpty() && curTime-list.getFirst()[0]>= duration){
            sum -= list.removeFirst()[1];
        }
    }

    private long findKth(long[] arr, int K){
        helper(arr, 0, arr.length-1, K);
        return arr[K];
    }

    private void helper(long[] arr, int start, int end, int k){
        if(start == end){
            return;
        }
        int pivotIdx = end;
        int i = start, j = end-1;
        while(i<=j){
            while(i<end && arr[i] < arr[pivotIdx]){
                i++;
            }
            while(j>=start && arr[j] > arr[pivotIdx]){
                j--;
            }
            if(i<=j){
                swap(arr, i++, j--);
            }
        }
        swap(arr, i, pivotIdx);
        pivotIdx = i;
        int order = pivotIdx-start+1;
        if(order == k){
            return;
        }
        else if(order > k){
            helper(arr, start, pivotIdx-1, k);
        }
        else{
            helper(arr, pivotIdx+1, end, k-order);
        }
    }

    private void swap(long[] arr, int i, int j){
        long tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```
```java
//version 2
    Deque<long[]> list  = new ArrayDeque<>();
    final long duration = 300000;
    long sum = 0;
    long num = 0;
    public void record(int val , long timestamp){
        clean();
        if(list.size()==0 || list.getLast()[0]+1000 > timestamp){
            list.add(new long[]{timestamp, val});
        }
        else{
            list.getLast()[1] += val;
        }
        sum += val;
        num ++;
    }

    public double getAve(){
        clean();
        return sum*1.0/num;
    }

    public void clean(){
        long curTime = System.currentTimeMillis();
        while(!list.isEmpty() && curTime-list.getFirst()[0]>= duration){
            sum -= list.removeFirst()[1];
            num--;
        }
    }
```

## classification
```java
// use logistic binary classification
public int predict(double[][] data, int[] labels, double[] x){
    double[] w = train(data, labels);
    double prob = sigmod(w, x);
    return prob>0.5? 1 : 0;
}

public double[] train(double[][] data, int[] labels){
    double[] w = new double[3];
    double step = 0.01;
    Arrays.fill(w, 1);
    // statistic gradient ascending
    // w_vec = w_vec + step * error_i * xi_vector
    // error_i = yi - sigmod(w_vec * xi_vector)
    // sigmod(z) = 1.0/(1+exp(-z))
    for(int i=0; i<data.length; i++){
        double coef = step * (labels[i]-sigmod(w, data[i]));
        w[0] += coef*data[i][0];
        w[1] += coef*data[i][1];
        w[2] += coef;
    }
    return w;
}

private double sigmod(double[] w, double[] x){
    double dotprod = w[0]*x[0]+w[1]*x[1]+w[2];
    return 1.0/(1+Math.exp(-dotprod));
}
```

## group character
```java
public static List<List<Character>> group(char[] A) {
    int[] counter = new int[26];
    Arrays.fill(counter, 0);
    for(char c : A){
        counter[c-'a'] += 1;
    }
    int max = 0;
    for(int i=0; i<counter.length; i++){
        max = Math.max(max, counter[i]);
    }
    List<List<Character>> ans = new ArrayList<>();
    for(int k=0; k<max; k++){
        ans.add(new ArrayList<>());
    }
    int k = 0;
    for(int i=0; i<counter.length; i++){
        char c = (char)('a'+i);
        for(int j=0; j<counter[i]; j++){
            ans.get(k).add(c);
            k = (k+1)%max;
        }
    }
    return ans;
}
```
## bold key words
### Version 1: indexOf
```java
public String boldKeyWord(String x, String word){
    if(x == null||x.length()==0){
        return "";
    }
    if(word==null || word.length() == 0 || x.length() < word.length()){
        return x;
    }
    int start = 0;
    int n = x.length();
    int d = word.length();
    StringBuilder sb = new StringBuilder();
    while(start<n){
        int idx = x.indexOf(word, start);
        if(idx == -1){
            break;
        }
        // check if [idx,..idx+d-1] is a substring of a word in x
        if(idx>0 && Character.isLetter(x.charAt(idx-1))
                || idx+d<n && Character.isLetter(x.charAt(idx+d))){
            start = idx+d;
        }
        else{
            sb.append(x.substring(start, idx));
            sb.append("<b>");
            sb.append(word);
            sb.append("</b>");
            start = idx+d;
        }
    }
    // if start == n, append an empty string
    sb.append(x.substring(start, n));
    return sb.toString();
}

public static void main(String[] args){
    String[] strs = {"this is all ralll alll rall all,",
            "this is all ralll alll rall all",
            "this is all ralll alll rall all hello"
    };
    String words[] = {"all", "rall all"};
    Solution sol = new Solution();
    for(int j=0; j<words.length; j++){
        for(int i=0; i<strs.length; i++){
            System.out.println(sol.boldKeyWord(strs[i], words[j]));
        }
    }
}
```
### Version 2, indexOf is not allowed, use JUnit
```java
public String boldKeyWord(String x, String word){
    if(x == null||x.length()==0){
        return "";
    }
    if(word==null || word.length() == 0 || x.length() < word.length()){
        return x;
    }
    int n = x.length();
    int d = word.length();
    StringBuilder sb = new StringBuilder();
    int i = 0;
    while(i<=n-d){
        if(!x.substring(i, i+d).equals(word)
                || i>0 && Character.isLetter(x.charAt(i-1))
                || i+d<n && Character.isLetter(x.charAt(i+d))){
            sb.append(x.charAt(i));
            i++;
        }
        else{
            sb.append("<b>");
            sb.append(word);
            sb.append("</b>");
            i = i+d;
        }
    }
    sb.append(x.substring(i, n));
    return sb.toString();
}

@Test
public void testBoldKeyWord(){
    String word= "all";
    String[][] cond = {{"this is all i", "this is <b>all</b> i"},
            {"this is hall", "this is hall"},
            {"this is all, hall", "this is <b>all</b>, hall"}};
    for(String[] pair : cond){
        Assert.assertEquals(boldKeyWord(pair[0], word), pair[1]);
    }
}
```
## summary range
```java
// best case: constant. Worse case: linear. Divide and Conquer. The conquer step takes constant time
// T(n) = 2*T(n/2)+c. By Master theory, T(n) = O(n).
public List<String> summaryRanges(int[] nums) {
    List<String> ans = new ArrayList<>();
    if(nums==null || nums.length == 0){
        return ans;
    }
    List<int[]> ranges = new ArrayList<>();
    helper(nums, 0, nums.length-1, ranges);
    for(int[] interval : ranges){
        if(interval[0] == interval[1]){
            ans.add(""+interval[0]);
        }
        else{
            ans.add(interval[0]+"->"+interval[1]);
        }
    }
    return ans;
}

public void helper(int[] nums, int left, int right, List<int[]> ranges){
    if(nums[right]-nums[left] == right-left){
        // add the range [left, right] into ranges;
        if(ranges.size()==0 || ranges.get(ranges.size()-1)[1]+1 < nums[left] ){
            ranges.add(new int[]{nums[left], nums[right]});
        }
        else{
            ranges.get(ranges.size()-1)[1] = nums[right];
        }
        return;
    }
    int mid = (right-left)/2+left;
    helper(nums, left, mid, ranges);
    helper(nums, mid+1, right, ranges);
}
```

```java
// sorted, containing duplicates
public List<String> summaryRanges(int[] nums) {
    List<String> ans = new ArrayList<>();
    if(nums==null || nums.length==0){
        return ans;
    }

    Integer start = nums[0], end = nums[0];
    for(int i=1; i<nums.length; i++){
        if(nums[i] == end){
            continue;
        }
        else if(nums[i]-end==1){
            end++;
        }
        else {
            helper(start, end, ans);
            start = nums[i];
            end = nums[i];
        }
    }
    helper(start, end, ans);
    return ans;
}

private void helper(Integer start, Integer end, List<String> ans){
    if(start.equals(end)){
        ans.add(""+start);
    }
    else{
        ans.add(start+"->"+end);
    }
}
```
```java
// unsorted, containging duplicates
public static List<int[]> summaryRange(int[] A) {
    // A is unsorted
    List<int[]> ans = new ArrayList<>();
    HashSet<Integer> record = new HashSet<>();
    for(int x : A){
        record.add(x);
    }

    for(int x : A){
        if(record.contains(x)){
            int start = x ;
            int end = x;
            record.remove(x);
            while(record.contains(start-1)){
                record.remove(--start);
            }
            while(record.contains(end+1)){
                record.remove(++end);
            }
            ans.add(new int[]{start, end});
        }
    }
    Collections.sort(ans, (a,b)->Integer.compare(a[0], b[0]));
    return ans;
}
```
## reverse html
```java
public String reverseHtml(String html){
    char[] arr = html.toCharArray();
    int n = html.length();
    reverse(arr, 0, n-1);
    int slow=0;
    for(int i=0; i<n; i++){
        if(arr[i]=='&' || arr[i]==';'){
            if(arr[i]==';'){
                slow = i;
            }
            else if(arr[slow] == ';'){
                reverse(arr, slow, i);
            }
        }
    }
    return new String(arr);
}

private void reverse(char[] arr, int start, int end){
    while(start<end){
        char tmp = arr[start];
        arr[start] = arr[end];
        arr[end] = tmp;
        start++;
        end--;
    }
}
```
```java
import org.junit.Assert;
import org.junit.Test;

public class Solution {
    // version 2, the interview ask you using stringbuilder. inplace is not allowed
    public static String reverseHtml(String html){
        StringBuilder sb = new StringBuilder();
        int slow = 0, i=0, n = html.length();
        for(; i<n; i++){
            char c = html.charAt(i);
            if(c!=';' || html.charAt(slow) != '&'){
                sb.insert(0, c);
                if( c== '&'){
                    slow = i;
                }
            }
            else{
                // html[i] = ';' && html[slow] = '&'
                int d = i-slow;
                sb.delete(0, d);
                for(int k = i; k>=slow; k--){
                    sb.insert(0, html.charAt(k));
                }
                slow = i+1;
            }
        }
        return sb.toString();
    }

    @Test
    public void testReverseHtml(){
        String[] raw = {"abc&123;", "abc&123", "abc&0&123;", "abc&123;0;", "abc1;23;"};
        String[] expected = {"&123;cba", "321&cba", "&123;0&cba", ";0&123;cba", ";32;1cba"};
        for(int i=0; i<raw.length; i++){
            Assert.assertEquals(expected[i], reverseHtml(raw[i]));
        }
    }

}
```

## merge k streams
```java
interface Stream{
    boolean move();
    Integer getValue();
}

public class Solution {
    private class Node{
        int val;
        Stream stream;
        Node(Stream stream){
            this.stream = stream;
            val = stream.getValue();
        }
    }
    public List<Integer> getElemOccurLeastK(List<Stream> lst, int k){
        List<Integer> ans = new ArrayList<>();
        if(lst == null || lst.size() == 0){
            return ans;
        }

        PriorityQueue<Node> heap = new PriorityQueue<>(lst.size(), (a,b)->Integer.compare(a.val, b.val));
        for(Stream s : lst){
            if(s.move()){
                heap.offer(new Node(s));
            }
        }

        while(heap.size()>=k){
            Node top = heap.poll();
            int val = top.val;
            int count = 1;
            update(top, heap);
            while(!heap.isEmpty() && heap.peek().val == val){
                count ++;
                update(heap.poll(), heap);
            }
            if(count>=k){
                ans.add(val);
            }
        }
        
        return ans;
    }

    private void update(Node top, PriorityQueue<Node> heap){
        int val = top.val;
        Stream s = top.stream;
        while(s.move()){
            int nextVal = s.getValue();
            if(val != nextVal){
                top.val = nextVal;
                heap.offer(top);
                break;
            }
        }
    }
}
```

## dice
```java
public float sumPro(int dice, int target){
    if(target<dice || target > 6*dice){
        return 0;
    }
    float[][] dp = new float[dice+1][target+1];
    dp[0][0] = 1;
    for(int i=1; i<=dice; i++){
        for(int j=i; j<=Math.min(target, 6*i); j++){
            for(int k=1; k<=6; k++){
                if( j-k<i-1 || j-k > 6*(i-1) ){
                    continue;
                }
                dp[i][j] += 1.0/6*(dp[i-1][j-k]);
            }
        }
    }
    return dp[dice][target];
}
```

## serialize tree
```java
private class Node{
    int val;
    Node left;
    Node right;
    Node(int val){
        this.val = val;
        left = null;
        right = null;
    }
}

public int[] serializeDense(Node root){
    // assume all root.val is positive
    if(root == null){
        return new int[0];
    }
    int h = getHeight(root);
    int len = (int) Math.pow(2, h)-1;
    int[] heap = new int[len];
    Queue<Node> q = new LinkedList<>();
    Queue<Integer> idxq = new LinkedList<>();
    q.offer(root);
    idxq.offer(0);
    while(!q.isEmpty()){
        Node cur = q.poll();
        int idx = idxq.poll();
        heap[idx] = cur.val;
        if(cur.left!=null){
            q.offer(cur.left);
            idxq.offer(idx*2+1);
        }
        if(cur.right!=null){
            q.offer(cur.right);
            idxq.offer(idx*2+2);
        }
    }
    return heap;
}

public int[][] serilizeSparse(Node root){
    if(root==null){
        return new int[0][0];
    }
    Map<Integer, Integer> mp = new HashMap<>();
    Queue<Node> q = new LinkedList<>();
    Queue<Integer> idxq = new LinkedList<>();
    q.offer(root);
    idxq.offer(0);
    while(!q.isEmpty()){
        Node cur = q.poll();
        int idx = idxq.poll();
        mp.put(idx, cur.val);
        if(cur.left!=null){
            q.offer(cur.left);
            idxq.offer(idx*2+1);
        }
        if(cur.right!=null){
            q.offer(cur.right);
            idxq.offer(idx*2+2);
        }
    }
    int n = mp.size();
    int[][] ans = new int[2][n];
    int j = 0;
    for(Integer idx : mp.keySet()){
        ans[0][j] = idx;
        ans[1][j] = mp.get(idx);
        j++;
    }
    return ans;
}

private int getHeight(Node cur){
    if(cur == null){
        return 0;
    }
    return 1+ Math.max(getHeight(cur.left), getHeight(cur.right));
}
```

## Expired Map
```java
class ExpiredMap<K,V>{

    private class Node{
        V val;
        long due;
        Node(V val, long due){
            this.val = val;
            this.due = due;
        }
    }

    private Map<K, Node> map;
    private Timer timer;

    public ExpiredMap(){
        map = new ConcurrentHashMap<>();
        TimerTask task = new TimerTask() {
            @Override
            public void run() {
                clean();
            }
        };
        timer = new Timer();
        timer.scheduleAtFixedRate(task, 10, 5);
    }

    public void put(K key, V val, int during){
        Node node = new Node(val, System.currentTimeMillis()+during);
        map.put(key, node);
    }

    public V get(K key){
        Node tmp = map.get(key);
        if(tmp == null ){
            return null;
        }
        if(tmp.due<=System.currentTimeMillis()){
            map.remove(key);
            return null;
        }
        return tmp.val;
    }

    private void clean(){
        Set<K> keys = map.keySet();
        // for( K key : map.keySet()) is not a good choice
        // because the iterator would be locked until out of scope
        for(K key : keys){
            get(key);
        }
    }

}
```

## NaryTree MincostPath
```java
private class Edge{
    int from;
    int to;
    int weight;

    public Edge(int from, int to, int weight) {
        this.from = from;
        this.to = to;
        this.weight = weight;
    }
}

private int mincost = Integer.MIN_VALUE;

public List<Integer> findMinRootLeafPath(Edge[] edges, int root){
    // Step 1: use HashMap to build a tree, key is the node label, val is the list of out edge label
    //    1
    //   /  \
    // 2     3
    // 1-> [(1,2,cost), (1,3, cost)]
    Map<Integer, List<Integer>> tree = new HashMap<>();
    for(int i=0; i<edges.length; i++){
        Edge e = edges[i];
        if(!tree.containsKey(e.from)){
            tree.put(e.from, new ArrayList<>());
        }
        if(!tree.containsKey(e.to)){
            tree.put(e.to, new ArrayList<>());
        }
        tree.get(e.from).add(i);
    }

    // Step 2: use dfs to find the mincost path. use a stack to record nodes in the current search path
    List<Integer> ans = new ArrayList<>();
    List<Integer> holder = new ArrayList<>();
    holder.add(root);
    dfs(tree, edges, ans, holder, 0, root);
    return ans;
}

private void dfs(Map<Integer, List<Integer>> tree, Edge[] edges, List<Integer> ans, List<Integer> holder, int cost, int curNode){
    if(tree.get(curNode).size()==0){
        // meet a leaf
        if(cost<mincost){
            mincost = cost;
            ans.clear();
            ans.addAll(holder);
        }
        return;
    }
    for(int i : tree.get(curNode)){
        Edge e = edges[i];
        int to = e.to;
        holder.add(to);
        dfs(tree, edges, ans, holder, cost+e.weight, to);
        holder.remove(holder.size()-1);
    }
}

// follow up: find min path between two node. Undirected Map
// Solution 1: Dijstra
public List<Integer> findMinPath(Edge[] edges, int src, int dst){
    Map<Integer, List<Integer>> g = new HashMap<>();
    for(int i=0; i<edges.length; i++){
        Edge e = edges[i];
        if(!g.containsKey(e.from)){
            g.put(e.from, new ArrayList<>());
        }
        if(!g.containsKey(e.to)){
            g.put(e.to, new ArrayList<>());
        }
        g.get(e.from).add(i);
        g.get(e.to).add(i);
    }


    Map<Integer, Integer> parent = new HashMap<>();
    Map<Integer, Integer> distance = new HashMap<>();
    for(int node : g.keySet()){
        distance.put(node, Integer.MAX_VALUE);
    }
    distance.put(src, 0);

    Set<Integer> done = new HashSet<>();
    // heapnode: distance to the src node, node label
    PriorityQueue<int[]> heap = new PriorityQueue<>(g.size(), (a, b)-> a[0]-b[0]);
    heap.offer(new int[]{0, src});

    while(!heap.isEmpty()){
        int[] top = heap.poll();
        int dist = top[0];
        int node = top[1];
        if(done.contains(node)){
            continue;
        }
        done.add(node);
        for(int i : g.get(node)){
            Edge e = edges[i];
            int nei = e.from == node? e.to : e.from;
            if(e.weight+dist < distance.get(nei)){
                distance.put(nei, e.weight+dist);
                parent.put(nei, node);
                heap.offer(new int[]{e.weight+dist, nei});
            }
        }
    }

    if(!done.contains(dst)){
        return new ArrayList<>();
    }

    LinkedList<Integer> path = new LinkedList<>();
    path.addFirst(dst);
    int cur = dst;
    while(parent.containsKey(cur)){
        path.addFirst(parent.get(cur));
        cur = parent.get(cur);
    }
    return path;

}
```

## Nary Tree Refactor
```java
public class Solution {
    public class Node{
        int label;
        List<Edge> edges;
    }

    public class Edge{
        int weight;
        Node to;
    }

    private int minCost = Integer.MIN_VALUE;

    public List<Node> findMinLeafPath(Node root){
        List<Node> ans = new ArrayList<>();
        if(root==null){
            return ans;
        }
        List<Node> holder = new ArrayList<>();
        holder.add(root);
        helper(ans, holder, 0, root);
        return ans;
    }

    private void helper(List<Node> ans, List<Node> holder, int curCost, Node cur){
        if(cur.edges == null || cur.edges.size() ==0){
            if(curCost < minCost){
                minCost = curCost;
                ans.clear();
                ans.addAll(holder);
            }
            return;
        }
        // early stop
        if(curCost >= minCost){
            return;
        }

        for(Edge e : cur.edges){
            holder.add(e.to);
            helper(ans, holder, curCost+e.weight, e.to);
            holder.remove(e.to);
        }
    }

    // follow up: undirected graph
    // dijltra
    // refactor class, only need Edge class
    private class Edge2{
        // assume node label is unique
        int node1;
        int node2;
        int weight;
    }
    public List<Integer> findMinPath(List<Edge2> edges, int src, int dst){
        // use adjacent matrix to represent the graph. Indeed, we could use a map
        // {node1 : {node2: weight}, node2: {node1: weight}}
        Map<Integer, Map<Integer, Integer>> g = new HashMap<>();
        for(Edge2 e : edges){
            if(!g.containsKey(e.node1)){
                g.put(e.node1, new HashMap<>());
            }
            g.get(e.node1).put(e.node2, e.weight);
            
            if(!g.containsKey(e.node2)){
                g.put(e.node2, new HashMap<>());
            }
            g.get(e.node2).put(e.node1, e.weight);
        }
        
        if(!g.containsKey(dst)){
            // unconnected component
            return new ArrayList<>();
        }
        
        Map<Integer, Integer> distance = new HashMap<>();
        for(int ky : g.keySet()){
            distance.put(ky, Integer.MAX_VALUE);
        }
        distance.put(src, 0);
        Map<Integer, Integer> parent = new HashMap<>();
        Set<Integer> done = new HashSet<>();
        int n = g.size();
        for(int i=0; i<n; i++){
            int closeNode = -1;
            int min = Integer.MAX_VALUE;
            for(int ky : g.keySet()){
                if(done.contains(ky) || distance.get(ky) >= min){
                    continue;
                }
                closeNode = ky;
                min = distance.get(ky);
            }
            
            done.add(closeNode);
            //early stop, but in the worse case, time complexity would still be O(n^2)
            if(done.contains(dst)){
                break;
            }
            for(int nei : g.get(closeNode).keySet()){
                int dist = distance.get(closeNode);
                if(dist + g.get(closeNode).get(nei) < distance.get(nei)){
                    distance.put(nei, dist + g.get(closeNode).get(nei));
                    parent.put(nei, closeNode);
                }
            }
        }
        
        LinkedList<Integer> path = new LinkedList<>();
        path.addFirst(dst);
        int cur = dst;
        while(parent.containsKey(cur)){
            path.addFirst(parent.get(cur));
            cur = parent.get(cur);
        }
        
        return path;
    }

}
```
